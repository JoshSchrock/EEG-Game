# -*- coding: utf-8 -*-
"""Copy of BrainNet-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NL2h9U8KGsDGT1sOaUdW9GSQ_54AiJAr
"""

# !pip install pyEDFlib
import pyedflib
import numpy as np
import warnings
import os  #  file paths
warnings.filterwarnings("ignore")

edf_file_name = ''
f = pyedflib.EdfReader(f"{os.getcwd()}\BCI Evasion 2\EEGExports\{edf_file_name}.edf")
n = f.signals_in_file
print("Signal Numbers:", n)

signal_labels = f.getSignalLabels()
print("Labels:", signal_labels)

signal_headers = f.getSignalHeaders()
# print("Headers:", signal_headers)
rate = signal_headers[0]['sample_rate']
print("Sample Rate:", rate)
f.close()

dur = f.getFileDuration()
print('Duration(s): ',dur)
x = np.zeros((n, f.getNSamples()[0]))
print(x.shape)

for i in range(n):

  f = pyedflib.EdfReader(f"{os.getcwd()}\BCI Evasion 2\EEGExports\{edf_file_name}.edf")
  if i>=4 and i<18:
    label = f.getLabel(i)
    print(label)
    x[i,:] = f.readSignal(i)
    print(x[i,:])
    print('----------------------------')
  f.close()

# !pip install mne

import numpy as np
import scipy.interpolate
from scipy import signal
from matplotlib import patches
import matplotlib.pyplot as plt
import mne

for num in range(1,26):
  file = f"{os.getcwd()}\BCI Evasion 2\EEGExports\{edf_file_name}.edf"
  data = mne.io.read_raw_edf(file)
  raw_data = data.get_data()
  eeg_data = raw_data[4:18,:]

print(eeg_data)

fig, ax = plt.subplots(figsize=(10,8))

powers = []
psds = list()
for sig in eeg_data:
  freq, psd = signal.welch(sig, 128)
  idx = np.logical_and(freq >= 0.5, freq <= 30)
  powers = np.append(powers, sum(psd[idx]))
  psds.append(psd[idx])
draw_cbar = True



N = 300            
xy_center = [2,2]  
radius = 2 

# AF3, F7, F3, FC5, T7, P7, O1, O2, P8, T8, FC6, F4, F8, AF4
ch_pos = [[1,4], [0.1,3], [1.5,3.5], [0.5,2.5], [-0.1,2], [0.4,0.4], [1.5,0], [2.5,0], 
          [3.6,0.4], [4.1,2], [3.5,2.5], [2.5,3.5], 
          [3.9,3], [3,4]]
x,y = [],[]
for i in ch_pos:
    x.append(i[0])
    y.append(i[1])

xi = np.linspace(-2, 6, N)
yi = np.linspace(-2, 6, N)
zi = scipy.interpolate.griddata((x, y), powers, (xi[None,:], yi[:,None]), method='cubic')

dr = xi[1] - xi[0]
for i in range(N):
    for j in range(N):
        r = np.sqrt((xi[i] - xy_center[0])**2 + (yi[j] - xy_center[1])**2)
        if (r - dr/2) > radius:
            zi[j,i] = "nan"
    
dist = ax.contourf(xi, yi, zi, 60, cmap = plt.get_cmap('coolwarm'), zorder = 1)
ax.contour(xi, yi, zi, 15, linewidths = 0.5,colors = "grey", zorder = 2)
    
if draw_cbar:
    cbar = fig.colorbar(dist, ax=ax, format='%.1e')
    cbar.ax.tick_params(labelsize=8)

ax.scatter(x, y, marker = 'o', c = 'b', s = 15, zorder = 3)
circle = patches.Circle(xy = xy_center, radius = radius, edgecolor = "k", facecolor = "none", zorder=4)
ax.add_patch(circle)

for loc, spine in ax.spines.items():
    spine.set_linewidth(0)
    
ax.set_xticks([])
ax.set_yticks([])

# left ear
circle = patches.Ellipse(xy = [0,2], width = 0.4, height = 1.0, angle = 0, edgecolor = "k", facecolor = "w", zorder = 0)
ax.add_patch(circle)
# right ear
circle = patches.Ellipse(xy = [4,2], width = 0.4, height = 1.0, angle = 0, edgecolor = "k", facecolor = "w", zorder = 0)
ax.add_patch(circle)

# nose   
xy = [[1.6,3.6], [2,4.3],[2.4,3.6]]
polygon = patches.Polygon(xy = xy, edgecolor = "k", facecolor = "w", zorder = 0)
ax.add_patch(polygon) 
    
ax.set_xlim(-0.5, 4.5)
ax.set_ylim(-0.5, 4.5)

plt.show()

import networkx as nx
from scipy import signal

NODES = 14

# functional connectivity----------------
C = np.zeros((NODES,NODES))
for i in range(NODES):
  for j in range(NODES):
    if i<j:
      freq, Cxy = signal.coherence(eeg_data[i,:], eeg_data[j,:], fs=128)
      idx = np.logical_and(freq >= 0.5, freq <= 30)
      C[i,j] = sum(Cxy[idx])
C_mean = np.sum(C)/(NODES*(NODES-1)/2)
print(C)
# plot------------------------------
fig, ax = plt.subplots(figsize=(8,8))


# left ear
circle = patches.Ellipse(xy=[0,2], width=0.4, height=1.0, angle=0, edgecolor="k", facecolor="w", zorder=0)
ax.add_patch(circle)
# right ear
circle = patches.Ellipse(xy=[4,2], width=0.4, height=1.0, angle=0, edgecolor="k", facecolor="w", zorder=0)
ax.add_patch(circle)
# nose   
xy = [[1.6,3.6],[2,4.3],[2.4,3.6]]
polygon = patches.Polygon(xy=xy, edgecolor="k", facecolor="w", zorder=0)
ax.add_patch(polygon) 
# head
circle = patches.Circle(xy=xy_center, radius=radius, edgecolor="k", facecolor="w", zorder=0)
ax.add_patch(circle)


# nodes
G = nx.Graph()
nodes_list = ['AF3','F7','F3','FC5','T7','P7','O1','O2','P8','T8','FC6','F4','F8','AF4']
G.add_nodes_from(nodes_list)
pos = {'AF3':[1,4], 'F7':[0.1,3], 'F3':[1.5,3.5], 'FC5':[0.5,2.5], 'T7':[-0.1,2], 'P7':[0.4,0.4], 
       'O1':[1.5,0], 'O2':[2.5,0], 'P8':[3.6,0.4], 'T8':[4.1,2], 'FC6':[3.5,2.5], 'F4':[2.5,3.5], 
       'F8':[3.9,3], 'AF4':[3,4]}

# edges
for i in range(NODES):
  for j in range(NODES):
    if i<j:
      edge = [(nodes_list[i],nodes_list[j])]
      if C[i,j] > C_mean: 
        G.add_edges_from(edge)
        nx.draw_networkx_edges(G, pos=pos, edgelist=edge, width=C[i,j]*0.1, edge_color='grey')

# hot nodes
color_map = []
for node in G:
  degree = G.degree(node)
  if degree < 3:
    color_map.append('yellow')
  elif 3 <= degree <= 6:
    color_map.append('orange')
  else:
    color_map.append('r')

nx.draw(G, pos=pos, with_labels=True, node_color=color_map, edge_color='grey')

'''
# try
color_map = []
for node in G:
  degree = G.degree(node)
  print(degree)
  if degree < 3:
    color_map.append('y')
    print('a')
  elif 3 <= degree < 6:
    color_map.append('orange')
    print('b')
  else:
    color_map.append('r')
    print('c')

  print(color_map)
nx.draw(G, node_color=color_map, with_labels=True)
'''

def draw_png(data):
  NODES = 14

  # functional connectivity----------------
  C = np.zeros((NODES,NODES))
  for i in range(NODES):
    for j in range(NODES):
      if i<j:
        freq, Cxy = signal.coherence(data[i], data[j], fs=128)
        idx = np.logical_and(freq>=0.5, freq<=30)
        C[i,j] = sum(Cxy[idx])
  C_mean = np.sum(C)/(NODES*(NODES-1)/2)
  print(C_mean)

  # plot------------------------------
  fig, ax = plt.subplots(figsize=(8,8))
  plt.xlim((-1,5))
  plt.ylim((-1,5))


  # left ear
  circle = patches.Ellipse(xy=[0,2], width=0.4, height=1.0, angle=0, edgecolor="k", facecolor="w", zorder=0)
  ax.add_patch(circle)
  # right ear
  circle = patches.Ellipse(xy=[4,2], width=0.4, height=1.0, angle=0, edgecolor="k", facecolor="w", zorder=0)
  ax.add_patch(circle)
  # nose   
  xy = [[1.6,3.6],[2,4.3],[2.4,3.6]]
  polygon = patches.Polygon(xy=xy, edgecolor="k", facecolor="w", zorder=0)
  ax.add_patch(polygon) 
  # head
  circle = patches.Circle(xy=xy_center, radius=radius, edgecolor="k", facecolor="w", zorder=0)
  ax.add_patch(circle)


  # nodes
  G = nx.Graph()
  nodes_list = ['AF3','F7','F3','FC5','T7','P7','O1','O2','P8','T8','FC6','F4','F8','AF4']
  G.add_nodes_from(nodes_list)
  pos = {'AF3':[1,4], 'F7':[0.1,3], 'F3':[1.5,3.5], 'FC5':[0.5,2.5], 'T7':[-0.1,2], 'P7':[0.4,0.4], 
       'O1':[1.5,0], 'O2':[2.5,0], 'P8':[3.6,0.4], 'T8':[4.1,2], 'FC6':[3.5,2.5], 'F4':[2.5,3.5], 
       'F8':[3.9,3], 'AF4':[3,4]}

  # edges
  for i in range(NODES):
    for j in range(NODES):
      if i<j:
        edge = [(nodes_list[i],nodes_list[j])]
        if C[i,j] > C_mean: 
          G.add_edges_from(edge)
          nx.draw_networkx_edges(G, pos=pos, edgelist=edge, width=C[i,j]*0.2, edge_color='grey')


  nx.draw(G, pos=pos, with_labels=True, node_color='r', edge_color='grey')

  return plt

ch_data = np.array_split(eeg_data, 50, axis=1)
for i in range(len(ch_data)):
  # print(ch_data.type)
  ax.clear
  plt = draw_png(ch_data[i])
  pngname = 'trial' + '1' + 'chunck' + str(i) + '.png'
  plt.savefig(pngname, format="PNG", bbox_inches='tight')

from PIL import Image
 
frames = []
    
for i in range(50):
   file = 'trial' + '1' + 'chunck' + str(i) + '.png'
   newFrame = Image.open(file)
   frames.append(newFrame)

# Save into a GIF file that loops forever
saveFile = f'{os.getcwd()}\EEGNetExports\Net_of_{edf_file_name}.gif'
frames[0].save(saveFile, format='GIF', append_images=frames[1:], 
               save_all=True, duration=300, loop=0)